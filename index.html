<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syrup - Real-Time Physics Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #fff;
            cursor: crosshair;
        }

        .controls {
            background: #f9f9f9;
            border-radius: 10px;
            padding: 20px;
        }

        .upload-section {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px dashed #ddd;
            text-align: center;
        }

        .upload-section:hover {
            border-color: #667eea;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .upload-btn:hover {
            transform: scale(1.05);
        }

        input[type="file"] {
            display: none;
        }

        .control-group {
            margin-bottom: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
        }

        .control-group h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        label {
            display: block;
            color: #555;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .slider-value {
            float: right;
            color: #667eea;
            font-weight: bold;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            font-size: 0.9em;
            color: #666;
        }

        .stats div {
            margin-bottom: 5px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üçØ Syrup</h1>
        <p class="subtitle">Real-Time Viscous Fluid Physics Simulation</p>
        
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas" width="800" height="600"></canvas>
                <p style="margin-top: 10px; color: #666;">Click on the canvas to add fluid</p>
            </div>
            
            <div class="controls">
                <div class="upload-section">
                    <h3 style="margin-bottom: 10px;">Height Map</h3>
                    <p style="color: #666; margin-bottom: 15px;">Upload a PNG to use as terrain</p>
                    <label for="fileInput" class="upload-btn">Choose PNG File</label>
                    <input type="file" id="fileInput" accept="image/png,image/jpg,image/jpeg">
                </div>
                
                <div class="control-group">
                    <h3>Height Map Parameters</h3>
                    <div class="slider-container">
                        <label>Height Scale <span class="slider-value" id="heightScaleValue">50</span></label>
                        <input type="range" id="heightScale" min="1" max="100" value="50">
                    </div>
                    <div class="slider-container">
                        <label>Smoothness <span class="slider-value" id="smoothnessValue">0</span></label>
                        <input type="range" id="smoothness" min="0" max="10" value="0">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Fluid Parameters</h3>
                    <div class="slider-container">
                        <label>Viscosity <span class="slider-value" id="viscosityValue">8</span></label>
                        <input type="range" id="viscosity" min="1" max="20" value="8">
                    </div>
                    <div class="slider-container">
                        <label>Gravity <span class="slider-value" id="gravityValue">10</span></label>
                        <input type="range" id="gravity" min="1" max="50" value="10">
                    </div>
                    <div class="slider-container">
                        <label>Flow Rate <span class="slider-value" id="flowRateValue">5</span></label>
                        <input type="range" id="flowRate" min="1" max="20" value="5">
                    </div>
                    <div class="slider-container">
                        <label>Fluid Amount <span class="slider-value" id="fluidAmountValue">20</span></label>
                        <input type="range" id="fluidAmount" min="5" max="50" value="20">
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Visualization</h3>
                    <div class="slider-container">
                        <label>Terrain Brightness <span class="slider-value" id="brightnessValue">50</span></label>
                        <input type="range" id="brightness" min="0" max="100" value="50">
                    </div>
                </div>
                
                <div class="button-group">
                    <button class="btn btn-primary" id="pauseBtn">Pause</button>
                    <button class="btn btn-secondary" id="resetFluidBtn">Clear Fluid</button>
                </div>
                
                <div class="stats">
                    <div><strong>FPS:</strong> <span id="fps">0</span></div>
                    <div><strong>Fluid Cells:</strong> <span id="fluidCells">0</span></div>
                    <div><strong>Resolution:</strong> <span id="resolution">800x600</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Simulation parameters
        let params = {
            heightScale: 50,
            smoothness: 0,
            viscosity: 8,
            gravity: 10,
            flowRate: 5,
            fluidAmount: 20,
            brightness: 50
        };
        
        // Simulation state
        let heightMap = null;
        let fluidCells = [];
        let paused = false;
        let lastFrameTime = Date.now();
        let fps = 0;
        let cachedTerrainImage = null;
        let lastHeightScale = params.heightScale;
        let lastBrightness = params.brightness;
        
        // Fluid cell structure: { x, y, height, color: {r, g, b}, vx, vy }
        
        // Initialize with a default height map
        function initializeDefaultHeightMap() {
            heightMap = new Array(width);
            for (let x = 0; x < width; x++) {
                heightMap[x] = new Array(height);
                for (let y = 0; y < height; y++) {
                    // Create a simple bowl shape as default
                    const dx = x - width / 2;
                    const dy = y - height / 2;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = Math.sqrt(width * width + height * height) / 2;
                    heightMap[x][y] = (dist / maxDist) * 100;
                }
            }
        }
        
        // Load PNG as height map
        function loadHeightMap(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    // Create temporary canvas to read pixel data
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0, width, height);
                    
                    const imageData = tempCtx.getImageData(0, 0, width, height);
                    const pixels = imageData.data;
                    
                    heightMap = new Array(width);
                    for (let x = 0; x < width; x++) {
                        heightMap[x] = new Array(height);
                        for (let y = 0; y < height; y++) {
                            const idx = (y * width + x) * 4;
                            // Use brightness as height
                            const brightness = (pixels[idx] + pixels[idx + 1] + pixels[idx + 2]) / 3;
                            heightMap[x][y] = brightness;
                        }
                    }
                    
                    // Apply smoothness
                    applySmoothing();
                    
                    // Invalidate terrain cache
                    cachedTerrainImage = null;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        // Apply Gaussian smoothing to height map
        function applySmoothing() {
            if (params.smoothness === 0 || !heightMap) return;
            
            const smoothed = new Array(width);
            for (let x = 0; x < width; x++) {
                smoothed[x] = new Array(height);
            }
            
            const kernel = params.smoothness;
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    let sum = 0;
                    let count = 0;
                    for (let dx = -kernel; dx <= kernel; dx++) {
                        for (let dy = -kernel; dy <= kernel; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                sum += heightMap[nx][ny];
                                count++;
                            }
                        }
                    }
                    smoothed[x][y] = sum / count;
                }
            }
            
            heightMap = smoothed;
        }
        
        // Get terrain height at position
        function getHeight(x, y) {
            if (!heightMap) return 0;
            if (!isFinite(x) || !isFinite(y)) return 0;
            x = Math.floor(x);
            y = Math.floor(y);
            if (x < 0 || x >= width || y < 0 || y >= height) return 0;
            return (heightMap[x][y] * params.heightScale) / 100;
        }
        
        // Add fluid at position
        function addFluid(x, y) {
            const color = {
                r: Math.random() * 200 + 55,
                g: Math.random() * 200 + 55,
                b: Math.random() * 200 + 55
            };
            
            for (let i = 0; i < params.fluidAmount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 15;
                fluidCells.push({
                    x: x + Math.cos(angle) * radius,
                    y: y + Math.sin(angle) * radius,
                    height: getHeight(x, y) + 5 + Math.random() * 5,
                    color: color,
                    vx: 0,
                    vy: 0
                });
            }
        }
        
        // Physics simulation step
        function simulateFluid(deltaTime) {
            const dt = Math.min(deltaTime / 1000, 0.1); // Cap at 0.1s
            const viscosityFactor = params.viscosity / 10;
            const gravityForce = params.gravity / 10;
            const flowSpeed = params.flowRate / 5;
            
            for (let i = 0; i < fluidCells.length; i++) {
                const cell = fluidCells[i];
                
                // Get current terrain height
                const terrainHeight = getHeight(cell.x, cell.y);
                
                // Calculate slope (gradient)
                const sampleDist = 2;
                const heightRight = getHeight(cell.x + sampleDist, cell.y);
                const heightLeft = getHeight(cell.x - sampleDist, cell.y);
                const heightDown = getHeight(cell.x, cell.y + sampleDist);
                const heightUp = getHeight(cell.x, cell.y - sampleDist);
                
                const gradX = (heightRight - heightLeft) / (sampleDist * 2);
                const gradY = (heightDown - heightUp) / (sampleDist * 2);
                
                // Apply gravity and slope forces
                cell.vx += -gradX * gravityForce * flowSpeed * dt;
                cell.vy += -gradY * gravityForce * flowSpeed * dt;
                
                // Check for fluid stacking (fluid rests on other fluid)
                let stackedHeight = terrainHeight;
                for (let j = 0; j < fluidCells.length; j++) {
                    if (i !== j) {
                        const other = fluidCells[j];
                        const dx = cell.x - other.x;
                        const dy = cell.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 3) {
                            // Fluid particles are close, can stack
                            if (other.height > stackedHeight) {
                                stackedHeight = Math.max(stackedHeight, other.height);
                            }
                        }
                    }
                }
                
                // Settle fluid on terrain or other fluid
                if (cell.height > stackedHeight + 1) {
                    cell.height -= gravityForce * dt * 10;
                    if (cell.height < stackedHeight + 1) {
                        cell.height = stackedHeight + 1;
                    }
                } else {
                    cell.height = stackedHeight + 1;
                }
                
                // Apply viscosity (damping)
                cell.vx *= Math.pow(1 - viscosityFactor, dt);
                cell.vy *= Math.pow(1 - viscosityFactor, dt);
                
                // Update position
                cell.x += cell.vx * dt * 50;
                cell.y += cell.vy * dt * 50;
                
                // Bounce off edges
                if (cell.x < 0) { cell.x = 0; cell.vx = Math.abs(cell.vx) * 0.5; }
                if (cell.x >= width) { cell.x = width - 1; cell.vx = -Math.abs(cell.vx) * 0.5; }
                if (cell.y < 0) { cell.y = 0; cell.vy = Math.abs(cell.vy) * 0.5; }
                if (cell.y >= height) { cell.y = height - 1; cell.vy = -Math.abs(cell.vy) * 0.5; }
            }
        }
        
        // Render the scene
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Render terrain
            if (heightMap) {
                // Cache terrain rendering if parameters haven't changed
                if (!cachedTerrainImage || lastHeightScale !== params.heightScale || lastBrightness !== params.brightness) {
                    const imageData = ctx.createImageData(width, height);
                    const pixels = imageData.data;
                    
                    const brightnessFactor = params.brightness / 50;
                    
                    for (let x = 0; x < width; x++) {
                        for (let y = 0; y < height; y++) {
                            const idx = (y * width + x) * 4;
                            const h = (heightMap[x][y] * params.heightScale) / 100;
                            const shade = Math.floor((h / 255) * 200 * brightnessFactor) + 30;
                            pixels[idx] = shade;
                            pixels[idx + 1] = shade;
                            pixels[idx + 2] = shade;
                            pixels[idx + 3] = 255;
                        }
                    }
                    
                    cachedTerrainImage = imageData;
                    lastHeightScale = params.heightScale;
                    lastBrightness = params.brightness;
                }
                
                ctx.putImageData(cachedTerrainImage, 0, 0);
            }
            
            // Sort fluid cells by height (back to front)
            fluidCells.sort((a, b) => a.height - b.height);
            
            // Render fluid cells
            for (const cell of fluidCells) {
                const size = 3;
                const alpha = 0.7;
                ctx.fillStyle = `rgba(${cell.color.r}, ${cell.color.g}, ${cell.color.b}, ${alpha})`;
                ctx.fillRect(cell.x - size / 2, cell.y - size / 2, size, size);
            }
        }
        
        // Animation loop
        function animate() {
            if (!paused) {
                const currentTime = Date.now();
                const deltaTime = currentTime - lastFrameTime;
                lastFrameTime = currentTime;
                
                // Update FPS
                fps = Math.round(1000 / deltaTime);
                document.getElementById('fps').textContent = fps;
                
                // Simulate physics
                simulateFluid(deltaTime);
                
                // Render
                render();
                
                // Update stats
                document.getElementById('fluidCells').textContent = fluidCells.length;
            }
            
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        document.getElementById('fileInput').addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                loadHeightMap(e.target.files[0]);
            }
        });
        
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addFluid(x, y);
        });
        
        // Slider event listeners
        function setupSlider(id, valueId, callback) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);
            slider.addEventListener('input', function() {
                valueDisplay.textContent = this.value;
                params[id] = parseFloat(this.value);
                if (callback) callback();
            });
        }
        
        setupSlider('heightScale', 'heightScaleValue');
        setupSlider('smoothness', 'smoothnessValue', () => {
            if (heightMap) {
                // Reload to reapply smoothing
                const fileInput = document.getElementById('fileInput');
                if (fileInput.files.length > 0) {
                    loadHeightMap(fileInput.files[0]);
                }
            }
        });
        setupSlider('viscosity', 'viscosityValue');
        setupSlider('gravity', 'gravityValue');
        setupSlider('flowRate', 'flowRateValue');
        setupSlider('fluidAmount', 'fluidAmountValue');
        setupSlider('brightness', 'brightnessValue');
        
        // Button event listeners
        document.getElementById('pauseBtn').addEventListener('click', function() {
            paused = !paused;
            this.textContent = paused ? 'Resume' : 'Pause';
            if (!paused) {
                lastFrameTime = Date.now();
            }
        });
        
        document.getElementById('resetFluidBtn').addEventListener('click', function() {
            fluidCells = [];
        });
        
        // Initialize and start
        initializeDefaultHeightMap();
        animate();
    </script>
</body>
</html>
